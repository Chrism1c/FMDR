# -*- coding: utf-8 -*-
"""SysAg2020 VGG16.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k8aPgGjpZNhSzRwBaExTyPUcQopMi2vU

# Actors Recognition from half face

```
# This is formatted as code
```

## Fine tuning
Per prima cosa, effettuiamo gli import necessari per l'esecuzione del progetto.
"""

from keras.applications import VGG16
from keras.models import Sequential
from keras.layers import Flatten, Dense, Dropout
from keras.preprocessing.image import ImageDataGenerator
from matplotlib import pyplot as plt
import random
from keras.optimizers import Adam
from keras.applications.vgg16 import preprocess_input
from keras.callbacks import ModelCheckpoint
from matplotlib import pyplot
import math
import os
import shutil
import cv2

"""Definiamo poi alcune costanti. Con `IMAGE_SIZE` specifichiamo la dimensione dell'immagine (altezza e larghezza) in pixel. VGG16 è stata addestrata su immagini a colori con dimensione 224x224 pixel."""

IMAGE_SIZE = 224
random.seed(3)

# path = '/gdrive/My Drive/SysAgdatasetCropped/train' + '/' + 'Angelina Jolie' + '/' + '166.jpg'
# im = pyplot.imread(path)


# def printImage(image):
#   pyplot.imshow(image)
#   pyplot.show()

# printImage(im)

# image_resized = cv2.resize(im, (224, 224))
# printImage(image_resized)

"""Carichiamo il modello VGG16, andando a definire con `weights` i pesi ottenuti con l'addestramento della rete su ImageNet, con `include_top` impostato a `False` decidiamo di non includere l'ultimo blocco di layer fully connected (Fully-Connected Classifier) e, infine, con `input_shape` definiamo la dimensione delle immagini in input alla rete."""

vgg16 = VGG16(weights=None, include_top=False, input_shape=(IMAGE_SIZE, IMAGE_SIZE, 3))

"""Per effettuare il fine tuning della rete, andiamo a congelare i pesi di tutti i layer, eccetto gli ultimi 4 (Conv Block #5)."""

for layer in vgg16.layers[:-4]:
  layer.trainable = False

"""Sostituiamo i layer non inclusi in precedenza con dei nuovi layer che si occuperanno di effettuare la classificazione. 

Andiamo quindi a creare un nuovo modello di tipo Sequential al quale aggiungiamo tutti i layer considerati in precedenza di VGG16 e i seguenti nuovi layer:
*   Flatten
*   Dense
*   Dropout
*   Dense
"""

model = Sequential()

model.add(vgg16)

model.add(Flatten())
model.add(Dense(1024, activation="relu"))
model.add(Dropout(0.5))
model.add(Dense(5, activation="softmax"))

vgg16.summary()
model.summary()

"""Definita la struttura della rete, andiamo a definire le cartelle per il training set e per il validation set.

Con la classe ImageDataGenerator si possono definire operazioni di preprocessing da effettuare sulle immagini ed eventuali operazioni di data augmentation per aumentare la numerosità dei set.
"""

# Commented out IPython magic to ensure Python compatibility.
# from google.colab import drive
# drive.mount('/gdrive')
# # %cd /gdrive/My Drive/SysAgdatasetCropped/

train_folder = "/gdrive/My Drive/SysAgDatasetFaceOnly/Train"
val_folder = "/gdrive/My Drive/SysAgDatasetFaceOnly/Val"

train_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)
val_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)

"""Con il metodo flow_from_directory() andiamo a creare i batch con le immagini preprocessate (ed, eventualmente, aumentate). 

Nel caso mostrato, la dimensione dei batch di training è di 34, mentre quella dei batch di validation è di 8.

Questi valori sono iperparametri e possono essere cambiati per cercare di migliorare le prestazioni della rete.
"""

# Split del dataset in val"

def splitDataset(trainPath,valPath):
  listOfactorsTrain = os.listdir(trainPath)
  listOfactorsVal = os.listdir(valPath)
  print(" listOfactorsTrain :" ,listOfactorsTrain)
  print(" listOfactorsVal :" ,listOfactorsVal)
  valPercent = 30
  for actor in listOfactorsTrain:
    actorPath = trainPath + '/' + actor
    actorsImages = os.listdir(actorPath)
    # print(actor," : ",actorsImages)
    numOfImages = len(actorsImages)
    print(actor," LEN : ",numOfImages)
    # numOfImages : 100 = x : valPercent
    valSize = int((numOfImages * valPercent)/100) 
    print(actor," valSize : ",valSize)
    valImages = actorsImages[:valSize]
    for image in valImages:
      shutil.move(trainPath + '/' + actor + '/' + image, valPath + '/' + actor)
      print("moved: ",image)

#splitDataset(train_folder, val_folder)

# %cd /gdrive/My Drive/SysAgWmask/Angelina Jolie-Mask
# # Search Colored pixel
# import cv2
# ###################################################################################################
# def printImage(image):
#   pyplot.imshow(image)
#   pyplot.show()

# def cropEyeLine(pixels, x,y):
#   crop = pixels[0:y][0:x]
#   # cv2_imshow(crop)
#   return crop

# def getMaskHigh():
#   # for i in range(imgShape[0]):
#   #   for j in range(imgShape[1]):
#   #     print(im[i,j])
#   #     if im[i,j,0] >= 77 and im[i,j,1] >= 218 and im[i,j,2] >= 235:
#   #       print("i ",i," j ",j)
#   #       break
#   pass

# path = '/gdrive/My Drive/SysAgWmask/Angelina Jolie-Mask'
# def cutImage():
#   filename = path + '/' + '1.jpg'
#   im = pyplot.imread(filename)
#   printImage(im)
#   imgShape = im.shape
#   # print("Size img : ",imgShape)
  
#   y = int(imgShape[1]/2.6)
#   x = imgShape[0]
#   newPixel = cropEyeLine(im, y, x)
#   printImage(newPixel)

# cutImage()

train_batchsize = 20      # Testare gli IperParametri
val_batchsize = 10

train_generator = train_datagen.flow_from_directory(
        train_folder,
        target_size=(IMAGE_SIZE, IMAGE_SIZE),
        batch_size=train_batchsize,
        class_mode="categorical"
)

val_generator = val_datagen.flow_from_directory(
        val_folder,
        target_size=(IMAGE_SIZE, IMAGE_SIZE),
        batch_size=val_batchsize,
        class_mode="categorical",
        shuffle=False
)

"""Per il salvataggio del modello, decidiamo di salvare il modello che, durante tutte le epoche di training, ha fatto registrare l'accuracy sul validation set maggiore.

Si possono definire altre azioni da eseguire al termine di ogni epoca. Creamo, a questo scopo, una lista chiamata `callbacks_list`.
"""

filepath = "/gdrive/My Drive/SysAgDatasetFaceOnly/vgg16_v1.hdf5"
checkpoint = ModelCheckpoint(filepath, monitor='val_acc', verbose=1, save_best_only=True, mode='max')
callbacks_list = [checkpoint]

"""Definiamo altri iperparametri per effettuare il training"""

num_epochs = 30
learning_rate = 1.25e-4
adam = Adam(lr=learning_rate)
model.compile(loss="categorical_crossentropy", optimizer=adam, metrics=['acc'])

"""Facciamo partire il training"""

history = model.fit_generator(
        train_generator,
        epochs=num_epochs,
        validation_data=val_generator,
        verbose=1,
        callbacks=callbacks_list
    )

"""Visualizziamo su grafico l'andamento dell'accuracy e della funzione di loss durante le epoche"""

acc = history.history['acc']
val_acc = history.history['val_acc']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(len(acc))

plt.plot(epochs, acc, 'b', label='Training acc')
plt.plot(epochs, val_acc, 'r', label='Validation acc')
plt.title('Training and validation accuracy')
plt.legend()

plt.figure()

plt.plot(epochs, loss, 'b', label='Training loss')
plt.plot(epochs, val_loss, 'r', label='Validation loss')
plt.title('Training and validation loss')
plt.legend()

plt.show()

"""## Test
Dopo aver creato il modello della nostra rete, possiamo testarlo con le immagini presenti nel test set.

Effettuiamo gli import necessari allo scopo.
"""

import numpy as np
from keras.models import load_model
from keras.preprocessing.image import ImageDataGenerator
import random
from sklearn import metrics
from sklearn.metrics import classification_report
from matplotlib import pyplot as plt
import seaborn as sns
from keras.applications.vgg16 import preprocess_input

"""E definiamo la funzione `show_confusion_matrix()` che ci servirà più tardi per creare il grafico con la matrice di confusione."""

def show_confusion_matrix(validations, predictions, labels):

    matrix = metrics.confusion_matrix(validations, predictions)
    plt.figure(figsize=(6, 4))
    sns.heatmap(matrix,
                cmap='coolwarm',
                linecolor='white',
                linewidths=1,
                xticklabels=labels,
                yticklabels=labels,
                annot=True,
                fmt='d')
    plt.title('Confusion Matrix')
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    plt.show()

"""Per prima cosa, impostiamo alcuni parametri, come il path del test set, la dimensione delle immagini in input alla rete e la dimensione del batch per il test"""

test_folder = "/gdrive/My Drive/SysAgDatasetFaceOnly/Test"# "/gdrive/My Drive/SysAgdatasetCropped/test/"
IMAGE_SIZE = 224
random.seed(3)
test_batchsize = 1

"""Successivamente, carichiamo il modello creato in precedenza"""

model = load_model("/gdrive/My Drive/SysAgDatasetFaceOnly/actor_recognition.hdf5")

"""E, proprio come per il training, andiamo a caricare le immagini con i seguenti metodi"""

test_datagen = ImageDataGenerator(preprocessing_function=preprocess_input)
test_generator = test_datagen.flow_from_directory(
        test_folder,
        target_size=(IMAGE_SIZE, IMAGE_SIZE),
        batch_size=test_batchsize,
        class_mode='categorical',
        shuffle=False)

"""Andiamo a leggere le classi assegnate agli esempi di test e il corrispettivo indice numerico"""

ground_truth = test_generator.classes
label2index = test_generator.class_indices
idx2label = dict((v, k) for k, v in label2index.items())

"""Effetuiamo la classificazione degli esempi di test"""

predictions = model.predict_generator(test_generator,
                      steps=test_generator.samples / test_generator.batch_size,
                      verbose=1)
predicted_classes = np.argmax(predictions, axis=1)

"""Calcoliamo il numero di errori effettuati dal modello, la matrice di confusione e visualizziamo le metriche prestazionali"""

errors = np.where(predicted_classes != ground_truth)[0]
print("No of errors = {}/{}".format(len(errors), test_generator.samples))
labels = ['Andrew Garfield', 'Angelina Jolie', 'Anthony Hopkins', 'Ben Affleck', 'Beyonce Knowles']
show_confusion_matrix(predicted_classes, ground_truth, labels)
print(classification_report(predicted_classes, ground_truth))